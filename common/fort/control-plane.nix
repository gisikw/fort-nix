# Fort Agent Module
#
# Defines fort.host.needs and fort.host.capabilities options for the unified control plane.
# See docs/control-plane-design.md for architecture details.
#
# fort.host.needs.<type>.<name>: Declares what a host needs from capability providers
# fort.host.capabilities.<name>: Declares what capabilities a host exposes
#
{ rootManifest, cluster, ... }:
{
  config,
  lib,
  pkgs,
  ...
}:
let
  domain = rootManifest.fortConfig.settings.domain;
  hostName = config.networking.hostName;

  # Read all host manifests for RBAC derivation
  hostFiles = builtins.readDir cluster.hostsDir;
  allHostManifests = builtins.mapAttrs
    (name: _: import (cluster.hostsDir + "/" + name + "/manifest.nix"))
    hostFiles;

  # Build hosts.json with peer public keys from cluster topology
  # For each host, get its device UUID and then the device's SSH public key
  getHostPubkey = hostName':
    let
      hostConfig = allHostManifests.${hostName'};
      deviceUuid = hostConfig.device;
      deviceManifestPath = cluster.devicesDir + "/${deviceUuid}/manifest.nix";
      deviceConfig = import deviceManifestPath;
    in {
      name = hostName';
      pubkey = deviceConfig.pubkey;
    };

  # Build hosts.json structure: { "hostname": { "pubkey": "ssh-ed25519 ..." }, ... }
  # Includes both hosts (from device manifests) and principals with agentKeys
  hostEntries = map (h:
    let info = getHostPubkey h;
    in { name = info.name; value = { pubkey = info.pubkey; }; }
  ) (builtins.attrNames allHostManifests);

  # Extract principals with agentKey for agent authentication
  principals = rootManifest.fortConfig.settings.principals or {};
  principalEntries = lib.mapAttrsToList (name: cfg:
    { inherit name; value = { pubkey = cfg.agentKey; }; }
  ) (lib.filterAttrs (name: cfg: cfg ? agentKey) principals);

  hostsJson = builtins.listToAttrs (hostEntries ++ principalEntries);

  fcgiSocket = "/run/fort/fcgi.sock";

  # Mandatory capability handlers (always present on all hosts)
  mandatoryHandlers = {
    # Return host status (generated by host-status aspect timer)
    status = pkgs.writeShellScript "handler-status" ''
      if [ -f /var/lib/fort/status/status.json ]; then
        ${pkgs.coreutils}/bin/cat /var/lib/fort/status/status.json
      else
        # Fallback if status.json doesn't exist yet
        uptime_secs=$(${pkgs.coreutils}/bin/cut -d' ' -f1 /proc/uptime | ${pkgs.coreutils}/bin/cut -d. -f1)
        ${pkgs.jq}/bin/jq -n \
          --arg hostname "${hostName}" \
          --argjson uptime "$uptime_secs" \
          --arg generated "$(${pkgs.coreutils}/bin/date -Iseconds)" \
          '{hostname: $hostname, status: "unknown", uptime_seconds: $uptime, generated_at: $generated}'
      fi
    '';

    # Return host manifest (apps, aspects, roles, exposedServices, capabilities)
    manifest = pkgs.writeShellScript "handler-manifest" ''
      ${pkgs.jq}/bin/jq -s '.[0] + {capabilities: .[1]}' \
        /var/lib/fort/host-manifest.json \
        /etc/fort/capabilities.json
    '';

    # Return holdings (handles this host is actively using)
    holdings = pkgs.writeShellScript "handler-holdings" ''
      if [ -f /var/lib/fort/holdings.json ]; then
        ${pkgs.coreutils}/bin/cat /var/lib/fort/holdings.json
      else
        echo '{"handles":[]}'
      fi
    '';

    # Fetch journalctl output for a unit (debug capability)
    journal = pkgs.writeShellScript "handler-journal" ''
      set -euo pipefail

      input=$(${pkgs.coreutils}/bin/cat)
      unit=$(echo "$input" | ${pkgs.jq}/bin/jq -r '.unit // empty')
      lines=$(echo "$input" | ${pkgs.jq}/bin/jq -r '.lines // 100')
      since=$(echo "$input" | ${pkgs.jq}/bin/jq -r '.since // empty')

      if [ -z "$unit" ]; then
        echo '{"error": "unit parameter required"}'
        exit 1
      fi

      # Build journalctl command
      args=("-u" "$unit" "-n" "$lines" "--no-pager" "-o" "short-iso")
      if [ -n "$since" ]; then
        args+=("--since" "$since")
      fi

      if output=$(${pkgs.systemd}/bin/journalctl "''${args[@]}" 2>&1); then
        ${pkgs.jq}/bin/jq -n --arg output "$output" '{"output": $output}'
      else
        ${pkgs.jq}/bin/jq -n --arg error "$output" '{"error": "journalctl failed", "details": $error}'
        exit 1
      fi
    '';

    # Restart a systemd unit (debug capability)
    # Optional delay parameter schedules restart in the future (useful for restarting nginx/fort-provider)
    restart = pkgs.writeShellScript "handler-restart" ''
      set -euo pipefail

      input=$(${pkgs.coreutils}/bin/cat)
      unit=$(echo "$input" | ${pkgs.jq}/bin/jq -r '.unit // empty')
      delay=$(echo "$input" | ${pkgs.jq}/bin/jq -r '.delay // 0')

      if [ -z "$unit" ]; then
        echo '{"error": "unit parameter required"}'
        exit 1
      fi

      # Basic validation: unit name should be reasonable
      if ! echo "$unit" | ${pkgs.gnugrep}/bin/grep -qE '^[a-zA-Z0-9@_.-]+$'; then
        echo '{"error": "invalid unit name"}'
        exit 1
      fi

      # Validate delay is a number
      if ! echo "$delay" | ${pkgs.gnugrep}/bin/grep -qE '^[0-9]+$'; then
        echo '{"error": "delay must be a non-negative integer (seconds)"}'
        exit 1
      fi

      if [ "$delay" -gt 0 ]; then
        # Schedule restart in the future - allows response to complete first
        if output=$(${pkgs.systemd}/bin/systemd-run --on-active="''${delay}s" \
            ${pkgs.systemd}/bin/systemctl restart "$unit" 2>&1); then
          ${pkgs.jq}/bin/jq -n --arg unit "$unit" --argjson delay "$delay" \
            '{"status": "scheduled", "unit": $unit, "delay_seconds": $delay}'
        else
          ${pkgs.jq}/bin/jq -n --arg unit "$unit" --arg error "$output" \
            '{"error": "schedule failed", "unit": $unit, "details": $error}'
          exit 1
        fi
      else
        # Immediate restart
        if output=$(${pkgs.systemd}/bin/systemctl restart "$unit" 2>&1); then
          ${pkgs.jq}/bin/jq -n --arg unit "$unit" '{"status": "restarted", "unit": $unit}'
        else
          ${pkgs.jq}/bin/jq -n --arg unit "$unit" --arg error "$output" \
            '{"error": "restart failed", "unit": $unit, "details": $error}'
          exit 1
        fi
      fi
    '';
  };

  # Mandatory capabilities config (no GC needed for these)
  mandatoryCapabilities = {
    status = { needsGC = false; ttl = 0; };
    manifest = { needsGC = false; ttl = 0; };
    holdings = { needsGC = false; ttl = 0; };
    # Debug capabilities - restricted to dev-sandbox principal
    journal = { needsGC = false; ttl = 0; allowed = [ "dev-sandbox" ]; };
    restart = { needsGC = false; ttl = 0; allowed = [ "dev-sandbox" ]; };
  };

  # All capabilities = mandatory + user-defined
  allCapabilities = mandatoryCapabilities // lib.mapAttrs (name: cfg: {
    needsGC = cfg.needsGC;
    ttl = cfg.ttl;
  }) config.fort.host.capabilities;

  # All hosts AND principals with agentKeys allowed to call mandatory endpoints
  principalNames = builtins.attrNames (lib.filterAttrs (name: cfg: cfg ? agentKey) principals);
  allHosts = builtins.attrNames allHostManifests ++ principalNames;

  # Derive RBAC from cluster topology
  # For each capability this host exposes, determine which hosts can call it
  deriveRbac = capabilities:
    lib.mapAttrs (capName: capCfg:
      if capCfg ? allowed && capCfg.allowed != null then
        # Restricted capability: only specified principals allowed
        capCfg.allowed
      else
        # Open capability: all cluster hosts and principals can call
        allHosts
    ) capabilities;

  # Need option type
  needOptions = {
    providers = lib.mkOption {
      type = lib.types.listOf lib.types.str;
      description = "Hostnames of capability providers to request from";
      example = [ "drhorrible" ];
    };

    request = lib.mkOption {
      type = lib.types.attrsOf lib.types.anything;
      default = { };
      description = "Request payload passed to the capability handler";
      example = { service = "outline"; };
    };

    store = lib.mkOption {
      type = lib.types.nullOr lib.types.str;
      default = null;
      description = "Path to store the response (null = don't store)";
      example = "/var/lib/fort/oidc/outline";
    };

    restart = lib.mkOption {
      type = lib.types.listOf lib.types.str;
      default = [ ];
      description = "Systemd services to restart after successful fulfillment";
      example = [ "outline.service" ];
    };

    reload = lib.mkOption {
      type = lib.types.listOf lib.types.str;
      default = [ ];
      description = "Systemd services to reload (not restart) after successful fulfillment";
      example = [ "nginx.service" ];
    };

    transform = lib.mkOption {
      type = lib.types.nullOr lib.types.path;
      default = null;
      description = ''
        Script to transform the response before storage.
        Called with: $1 = store path, stdin = response body JSON.
        If null, raw response body is written to store path.
      '';
      example = "./extract-token.sh";
    };

    identity = lib.mkOption {
      type = lib.types.nullOr (lib.types.submodule {
        options = {
          origin = lib.mkOption {
            type = lib.types.str;
            description = "Origin header value (principal name) to use for authentication";
          };
          keyPath = lib.mkOption {
            type = lib.types.str;
            description = "Path to SSH key for signing requests";
          };
        };
      });
      default = null;
      description = ''
        Override identity for this need. If null, uses host identity.
        Use this when the need requires authentication as a different principal
        (e.g., dev-sandbox principal for RW git access).
      '';
      example = {
        origin = "dev-sandbox";
        keyPath = "/var/lib/fort/dev-sandbox/agent-key";
      };
    };
  };

  # Capability option type
  capabilityOptions = {
    handler = lib.mkOption {
      type = lib.types.path;
      description = "Path to handler script";
    };

    needsGC = lib.mkOption {
      type = lib.types.bool;
      default = false;
      description = "Whether this capability needs garbage collection (adds handle wrapper)";
    };

    ttl = lib.mkOption {
      type = lib.types.int;
      default = 86400;
      description = "Time-to-live in seconds for GC-able responses (only used if needsGC = true)";
      example = 3600;
    };

    satisfies = lib.mkOption {
      type = lib.types.nullOr lib.types.str;
      default = null;
      description = ''
        The need type this capability satisfies. Used for documentation and
        potentially for RBAC derivation (finding hosts that declare matching needs).
        If null, defaults to the capability name itself.

        Example: capability "oidc-register" might set satisfies = "oidc" to match
        fort.host.needs.oidc.* declarations.
      '';
      example = "oidc";
    };

    description = lib.mkOption {
      type = lib.types.str;
      default = "";
      description = "Human-readable description of the capability";
    };

    allowed = lib.mkOption {
      type = lib.types.nullOr (lib.types.listOf lib.types.str);
      default = null;
      description = ''
        List of principal names allowed to call this capability.
        If null (default), all hosts and principals can call it.
        If specified, only the listed principals are allowed (not hosts).
      '';
      example = [ "dev-sandbox" ];
    };
  };

  # Generate needs.json from all fort.host.needs declarations
  #
  # Structure: fort.host.needs.<capability>.<name> = { providers, request, store, restart }
  # The first key IS the capability name - no magic transformation.
  # Example: fort.host.needs.ssl-cert.wildcard calls the "ssl-cert" capability
  needsJson = let
    flattenNeeds = needs:
      lib.concatLists (lib.mapAttrsToList (capability:
        lib.mapAttrsToList (name: cfg: {
          id = "${capability}-${name}";
          inherit capability;
          inherit (cfg) providers request restart reload;
          store = cfg.store;
          transform = if cfg.transform != null then toString cfg.transform else null;
          identity = if cfg.identity != null then {
            origin = cfg.identity.origin;
            keyPath = cfg.identity.keyPath;
          } else null;
        })
      ) needs);
  in builtins.toJSON (flattenNeeds config.fort.host.needs);

  # RBAC for mandatory endpoints (respects allowed if specified)
  mandatoryRbac = deriveRbac mandatoryCapabilities;

  # Generate rbac.json from capabilities and topology (includes mandatory)
  rbacJson = builtins.toJSON (mandatoryRbac // deriveRbac config.fort.host.capabilities);

  # Generate capabilities.json with needsGC and ttl settings (includes mandatory)
  capabilitiesJson = builtins.toJSON allCapabilities;

  # Import the provider (FastCGI handler)
  fortProvider = import ../../pkgs/fort-provider { inherit pkgs; };

  # Import fort CLI for consumer service
  fortCli = import ../../pkgs/fort { inherit pkgs domain; };

  # Fulfill script - reads needs.json and calls providers
  fortFulfillScript = pkgs.writeShellScript "fort-fulfill" ''
    set -euo pipefail

    NEEDS_FILE="/var/lib/fort/needs.json"
    HOLDINGS_FILE="/var/lib/fort/holdings.json"
    HANDLES_DIR="/var/lib/fort/handles"

    log() { echo "[fort-fulfill] $*"; }

    # Exit early if no needs file
    if [ ! -f "$NEEDS_FILE" ]; then
      log "No needs.json found, nothing to fulfill"
      exit 0
    fi

    # Ensure handles directory exists
    ${pkgs.coreutils}/bin/mkdir -p "$HANDLES_DIR"

    # Track holdings for final output
    declare -A HOLDINGS

    # Read needs.json and process each need
    needs=$(${pkgs.jq}/bin/jq -c '.[]' "$NEEDS_FILE")

    while IFS= read -r need; do
      [ -z "$need" ] && continue

      id=$(echo "$need" | ${pkgs.jq}/bin/jq -r '.id')
      capability=$(echo "$need" | ${pkgs.jq}/bin/jq -r '.capability')
      store=$(echo "$need" | ${pkgs.jq}/bin/jq -r '.store // empty')
      request=$(echo "$need" | ${pkgs.jq}/bin/jq -c '.request // {}')
      providers=$(echo "$need" | ${pkgs.jq}/bin/jq -r '.providers[]')
      restart_services=$(echo "$need" | ${pkgs.jq}/bin/jq -r '.restart // [] | .[]')
      reload_services=$(echo "$need" | ${pkgs.jq}/bin/jq -r '.reload // [] | .[]')
      transform=$(echo "$need" | ${pkgs.jq}/bin/jq -r '.transform // empty')
      identity_origin=$(echo "$need" | ${pkgs.jq}/bin/jq -r '.identity.origin // empty')
      identity_key=$(echo "$need" | ${pkgs.jq}/bin/jq -r '.identity.keyPath // empty')

      # Determine handle path
      if [ -n "$store" ]; then
        handle_path="''${store}.handle"
      else
        handle_path="$HANDLES_DIR/$id"
      fi

      # Check if already fulfilled (handle file exists and non-empty)
      if [ -f "$handle_path" ] && [ -s "$handle_path" ]; then
        handle=$(${pkgs.coreutils}/bin/cat "$handle_path")
        log "[$id] Already fulfilled (handle: $handle)"
        HOLDINGS["$id"]="$handle"
        continue
      fi

      # Try each provider in order
      fulfilled=false
      for provider in $providers; do
        log "[$id] Calling $provider/$capability..."

        # Build environment for fort (identity override if specified)
        call_env=""
        if [ -n "$identity_origin" ] && [ -n "$identity_key" ]; then
          call_env="FORT_ORIGIN=$identity_origin FORT_SSH_KEY=$identity_key"
          log "[$id] Using identity: $identity_origin"
        fi

        if result=$(env $call_env ${fortCli}/bin/fort "$provider" "$capability" "$request" 2>&1); then
          status=$(echo "$result" | ${pkgs.jq}/bin/jq -r '.status')
          handle=$(echo "$result" | ${pkgs.jq}/bin/jq -r '.handle // empty')
          body=$(echo "$result" | ${pkgs.jq}/bin/jq -c '.body')

          if [ "$status" -ge 200 ] && [ "$status" -lt 300 ]; then
            log "[$id] Success from $provider (HTTP $status)"

            # Store response if store path specified
            if [ -n "$store" ]; then
              ${pkgs.coreutils}/bin/mkdir -p "$(${pkgs.coreutils}/bin/dirname "$store")"
              if [ -n "$transform" ]; then
                # Use transform script to process response
                echo "$body" | "$transform" "$store"
                log "[$id] Transformed response to $store"
              else
                # Store raw response
                echo "$body" | ${pkgs.jq}/bin/jq '.' > "$store"
                log "[$id] Stored response at $store"
              fi
            fi

            # Store handle if returned
            if [ -n "$handle" ]; then
              ${pkgs.coreutils}/bin/mkdir -p "$(${pkgs.coreutils}/bin/dirname "$handle_path")"
              echo "$handle" > "$handle_path"
              HOLDINGS["$id"]="$handle"
              log "[$id] Stored handle at $handle_path"
            fi

            # Reload services (graceful)
            for service in $reload_services; do
              if ${pkgs.systemd}/bin/systemctl reload "$service" 2>&1; then
                log "[$id] Reloaded $service"
              else
                log "[$id] Warning: failed to reload $service"
              fi
            done

            # Restart services
            for service in $restart_services; do
              if ${pkgs.systemd}/bin/systemctl restart "$service" 2>&1; then
                log "[$id] Restarted $service"
              else
                log "[$id] Warning: failed to restart $service"
              fi
            done

            fulfilled=true
            break
          else
            log "[$id] Provider $provider returned HTTP $status"
          fi
        else
          log "[$id] Provider $provider failed: $result"
        fi
      done

      if [ "$fulfilled" = false ]; then
        log "[$id] All providers failed, will retry later"
      fi
    done <<< "$needs"

    # Write holdings.json
    # Disable strict unset checking - associative arrays can be tricky with set -u
    set +u
    holdings_json='{"handles":['
    first=true
    for id in "''${!HOLDINGS[@]}"; do
      if [ "$first" = true ]; then
        first=false
      else
        holdings_json+=','
      fi
      holdings_json+="{\"id\":\"$id\",\"handle\":\"''${HOLDINGS[$id]}\"}"
    done
    holdings_json+=']}'
    holdings_count="''${#HOLDINGS[@]}"
    set -u  # Re-enable strict mode

    echo "$holdings_json" | ${pkgs.jq}/bin/jq '.' > "$HOLDINGS_FILE"
    log "Updated holdings.json with $holdings_count handle(s)"

    exit 0
  '';

  # Check if we have any needs or capabilities defined
  hasNeeds = config.fort.host.needs != { };
  hasCapabilities = config.fort.host.capabilities != { };

in
{
  options.fort.host = {
    needs = lib.mkOption {
      type = lib.types.attrsOf (lib.types.attrsOf (lib.types.submodule { options = needOptions; }));
      default = { };
      description = ''
        Declares what this host needs from capability providers.
        Structure: fort.host.needs.<capability>.<id> = { providers, request, store, restart }

        The first key is the capability to call. The second key is an arbitrary
        identifier for disambiguation - use "default" for singletons, or a
        descriptive id when you have multiple needs of the same capability.
        All actual parameters go in the request field.

        Examples:
          # Singleton - just use "default"
          fort.host.needs.ssl-cert.default = {
            providers = [ "drhorrible" ];
            store = "/var/lib/fort/ssl";
            restart = [ "nginx.service" ];
          };

          # Multiple of same capability - use descriptive ids
          fort.host.needs.oidc-register.outline = {
            providers = [ "drhorrible" ];
            request = { service = "outline"; };
            store = "/var/lib/fort/oidc/outline";
            restart = [ "outline.service" ];
          };
      '';
      example = {
        ssl-cert.default = {
          providers = [ "drhorrible" ];
          request = { };
          store = "/var/lib/fort/ssl";
          restart = [ "nginx.service" ];
        };
      };
    };

    capabilities = lib.mkOption {
      type = lib.types.attrsOf (lib.types.submodule { options = capabilityOptions; });
      default = { };
      description = ''
        Declares what capabilities this host exposes via the agent API.
        RBAC rules are derived automatically from cluster topology.

        Examples:
          fort.host.capabilities.ssl-cert = {
            handler = ./handlers/ssl-cert;
            description = "Return cluster SSL certificates";
          };

          fort.host.capabilities.oidc-register = {
            handler = ./handlers/oidc-register;
            needsGC = true;  # Creates GC-able state
            description = "Register OIDC client in pocket-id";
          };
      '';
      example = {
        ssl-cert = {
          handler = ./handlers/ssl-cert;
          description = "Return cluster SSL certificates";
        };
      };
    };
  };

  config = lib.mkMerge [
    # Core agent infrastructure - always present on all hosts
    {
      # Generate hosts.json with peer public keys and install mandatory handlers
      system.activationScripts.fortProviderConfig = {
        deps = [ ];
        text = ''
          install -d -m0755 /etc/fort
          install -d -m0755 /etc/fort/handlers
          install -Dm0644 ${pkgs.writeText "hosts.json" (builtins.toJSON hostsJson)} /etc/fort/hosts.json

          # Install mandatory handlers
          install -Dm0755 ${mandatoryHandlers.status} /etc/fort/handlers/status
          install -Dm0755 ${mandatoryHandlers.manifest} /etc/fort/handlers/manifest
          install -Dm0755 ${mandatoryHandlers.holdings} /etc/fort/handlers/holdings
          install -Dm0755 ${mandatoryHandlers.journal} /etc/fort/handlers/journal
          install -Dm0755 ${mandatoryHandlers.restart} /etc/fort/handlers/restart

          # Install RBAC and capabilities config (includes mandatory endpoints)
          install -Dm0644 ${pkgs.writeText "rbac.json" rbacJson} /etc/fort/rbac.json
          install -Dm0644 ${pkgs.writeText "capabilities.json" capabilitiesJson} /etc/fort/capabilities.json
        '';
      };

      # Runtime directory for socket and persistent handles storage
      systemd.tmpfiles.rules = [
        "d /run/fort 0755 root root -"
        "d /var/lib/fort/handles 0700 root root -"
      ];

      # Socket activation for the FastCGI provider
      systemd.sockets.fort-provider = {
        description = "Fort Control Plane Provider Socket";
        wantedBy = [ "sockets.target" ];
        listenStreams = [ fcgiSocket ];
        socketConfig = {
          SocketMode = "0660";
          SocketUser = "root";
          SocketGroup = "nginx";
        };
      };

      # The actual service (activated by socket)
      systemd.services.fort-provider = {
        description = "Fort Control Plane Provider";
        requires = [ "fort-provider.socket" ];
        after = [ "fort-provider.socket" ];
        restartTriggers = [ fortProvider ];  # Restart when binary changes

        serviceConfig = {
          Type = "simple";
          ExecStart = "${fortProvider}/bin/fort-provider";
          StandardInput = "socket";
          StandardOutput = "socket";
          StandardError = "journal";
        };
      };

      # Watch for config changes and restart fort-provider
      # capabilities.json is regenerated on every activation and reflects all capability changes
      systemd.paths.fort-provider-config = {
        description = "Watch for fort-provider config changes";
        wantedBy = [ "multi-user.target" ];
        pathConfig = {
          PathModified = "/etc/fort/capabilities.json";
        };
      };

      systemd.services.fort-provider-config = {
        description = "Restart fort-provider on config change";
        serviceConfig = {
          Type = "oneshot";
          ExecStart = "${pkgs.systemd}/bin/systemctl restart fort-provider.service";
        };
      };

      # Control plane endpoint - VPN-only access for cluster-internal communication
      services.nginx.virtualHosts."${hostName}.fort.${domain}" = {
        locations."/fort/" = {
          extraConfig = ''
            if ($is_vpn = 0) {
              return 444;
            }

            fastcgi_pass unix:${fcgiSocket};
            include ${pkgs.nginx}/conf/fastcgi_params;
            fastcgi_param SCRIPT_NAME $uri;
            fastcgi_param REQUEST_METHOD $request_method;
            fastcgi_param CONTENT_TYPE $content_type;
            fastcgi_param CONTENT_LENGTH $content_length;
            fastcgi_param QUERY_STRING $query_string;

            # Auth headers for signature verification
            fastcgi_param HTTP_X_FORT_ORIGIN $http_x_fort_origin;
            fastcgi_param HTTP_X_FORT_TIMESTAMP $http_x_fort_timestamp;
            fastcgi_param HTTP_X_FORT_SIGNATURE $http_x_fort_signature;
          '';
        };
      };
    }

    # Generate needs.json and consumer services if any needs are declared
    (lib.mkIf hasNeeds {
      system.activationScripts.fortNeedsJson = {
        deps = [ "fortHostManifest" ];
        text = ''
          install -Dm0644 ${pkgs.writeText "needs.json" needsJson} /var/lib/fort/needs.json
        '';
      };

      # Consumer service - runs at activation to satisfy needs
      systemd.services.fort-consumer = {
        description = "Fort control plane consumer";
        after = [ "network-online.target" "fort-provider.service" ];
        wants = [ "network-online.target" ];
        wantedBy = [ "multi-user.target" ];

        serviceConfig = {
          Type = "oneshot";
          RemainAfterExit = true;
          ExecStart = fortFulfillScript;
        };

        path = [ fortCli pkgs.jq pkgs.coreutils pkgs.systemd ];
      };

      # Retry timer - periodically re-attempts unfulfilled needs
      systemd.timers.fort-consumer-retry = {
        description = "Retry unfulfilled fort consumer needs";
        wantedBy = [ "timers.target" ];
        timerConfig = {
          OnBootSec = "5m";
          OnUnitActiveSec = "5m";
        };
      };

      systemd.services.fort-consumer-retry = {
        description = "Retry unfulfilled fort consumer needs";
        serviceConfig = {
          Type = "oneshot";
          ExecStart = fortFulfillScript;
        };

        path = [ fortCli pkgs.jq pkgs.coreutils pkgs.systemd ];
      };
    })

    # Install user-defined capability handlers (if any)
    (lib.mkIf hasCapabilities {
      system.activationScripts.fortProviderHandlers = {
        deps = [ "fortProviderConfig" ];
        text = ''
          # Install user-defined handler scripts
          ${lib.concatStringsSep "\n" (lib.mapAttrsToList (name: cfg: ''
            install -Dm0755 ${cfg.handler} /etc/fort/handlers/${name}
          '') config.fort.host.capabilities)}
        '';
      };
    })
  ];
}
