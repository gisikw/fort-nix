name: Release

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  check:
    runs-on: nixos
    steps:
      - uses: actions/checkout@v4

      - name: Check root flake
        run: nix flake check --no-build
        env:
          NIX_CONFIG: "warn-dirty = false"

      - name: Check host flakes
        run: |
          for host_dir in ./clusters/bedlam/hosts/*/; do
            host=$(basename "$host_dir")
            echo "::group::Checking host: $host"
            nix flake check "$host_dir" --no-build
            echo "::endgroup::"
          done
        env:
          NIX_CONFIG: "warn-dirty = false"

      - name: Check device flakes
        run: |
          for device_dir in ./clusters/bedlam/devices/*/; do
            device=$(basename "$device_dir")
            echo "::group::Checking device: $device"
            nix flake check "$device_dir" --no-build
            echo "::endgroup::"
          done
        env:
          NIX_CONFIG: "warn-dirty = false"

  release:
    needs: check
    if: github.event_name == 'push'
    runs-on: nixos
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Collect secrets and build recipients map
        id: collect
        run: |
          mkdir -p /tmp/release-work

          # Will hold: { "path/to/secret.age": ["key1", "key2", ...], ... }
          echo '{}' > /tmp/release-work/recipients-map.json

          for host_dir in ./clusters/bedlam/hosts/*/; do
            host=$(basename "$host_dir")
            echo "::group::Collecting secrets for $host"

            # Get device UUID from host manifest
            device_uuid=$(nix eval --raw --file "${host_dir}/manifest.nix" device 2>/dev/null || echo "")
            if [ -z "$device_uuid" ]; then
              echo "::warning::Could not get device UUID for $host, skipping"
              echo "::endgroup::"
              continue
            fi

            # Get device public key
            device_key=$(nix eval --raw --file "./clusters/bedlam/devices/${device_uuid}/manifest.nix" pubkey 2>/dev/null || echo "")
            if [ -z "$device_key" ]; then
              echo "::warning::Could not get device key for $host (device $device_uuid), skipping"
              echo "::endgroup::"
              continue
            fi

            echo "Device: $device_uuid"
            echo "Key: ${device_key:0:20}..."

            # Get secrets this host uses
            secrets_json=$(nix eval "${host_dir}#nixosConfigurations.${host}.config.age.secrets" --json 2>/dev/null || echo "{}")

            # Extract .file paths and add device key to recipients map
            echo "$secrets_json" | jq -r 'to_entries[] | .value.file // empty' | while read -r secret_file; do
              # Strip /nix/store/*-source/ prefix to get relative path
              secret_path=$(echo "$secret_file" | sed 's|^/nix/store/[^/]*-source/||')
              echo "  Secret: $secret_path"

              # Add key to this secret's recipient list in the map
              jq --arg path "$secret_path" --arg key "$device_key" \
                '.[$path] = ((.[$path] // []) + [$key] | unique | sort)' \
                /tmp/release-work/recipients-map.json > /tmp/release-work/recipients-map.json.tmp
              mv /tmp/release-work/recipients-map.json.tmp /tmp/release-work/recipients-map.json
            done

            echo "::endgroup::"
          done

          echo "Final recipients map:"
          jq . /tmp/release-work/recipients-map.json
        env:
          NIX_CONFIG: "warn-dirty = false"

      - name: Fetch previous recipients map
        run: |
          # Try to get the previous map from release branch
          if git show origin/release:.release-recipients.json > /tmp/release-work/previous-map.json 2>/dev/null; then
            echo "Found previous recipients map"
            jq . /tmp/release-work/previous-map.json
          else
            echo "No previous map found, all secrets will be re-keyed"
            echo '{}' > /tmp/release-work/previous-map.json
          fi

      - name: Determine secrets to re-key
        run: |
          # Compare maps and output list of secrets that need re-keying
          jq -n --slurpfile current /tmp/release-work/recipients-map.json \
                --slurpfile previous /tmp/release-work/previous-map.json '
            ($current[0] | keys) as $all_secrets |
            $all_secrets | map(
              select(
                ($current[0][.] | tojson) != ($previous[0][.] // [] | tojson)
              )
            )
          ' > /tmp/release-work/secrets-to-rekey.json

          echo "Secrets needing re-key:"
          jq -r '.[]' /tmp/release-work/secrets-to-rekey.json

          count=$(jq length /tmp/release-work/secrets-to-rekey.json)
          total=$(jq 'keys | length' /tmp/release-work/recipients-map.json)
          echo "Re-keying $count of $total secrets"

      - name: Copy unchanged secrets from release branch
        run: |
          # For secrets with unchanged recipients, copy from release HEAD
          # This preserves stable ciphertext and avoids spurious changes
          jq -r 'keys[]' /tmp/release-work/recipients-map.json | while read -r secret_path; do
            # Skip if this secret needs re-keying
            if jq -e --arg p "$secret_path" 'index($p)' /tmp/release-work/secrets-to-rekey.json >/dev/null 2>&1; then
              continue
            fi

            # Try to copy from release branch
            if git show "origin/release:${secret_path}" > "${secret_path}.release" 2>/dev/null; then
              echo "Preserving unchanged: $secret_path"
              mv "${secret_path}.release" "$secret_path"
            else
              echo "::warning::Secret $secret_path not in release branch, will need re-key"
              # Add to re-key list
              jq --arg p "$secret_path" '. + [$p]' /tmp/release-work/secrets-to-rekey.json > /tmp/release-work/secrets-to-rekey.json.tmp
              mv /tmp/release-work/secrets-to-rekey.json.tmp /tmp/release-work/secrets-to-rekey.json
            fi
          done

      - name: Re-key changed secrets
        env:
          CI_AGE_KEY: ${{ secrets.CI_AGE_KEY }}
        run: |
          echo "$CI_AGE_KEY" > /tmp/ci-age-key.txt
          trap 'rm -f /tmp/ci-age-key.txt' EXIT

          # Process only secrets that need re-keying
          jq -r '.[]' /tmp/release-work/secrets-to-rekey.json | while read -r secret_path; do
            [ -n "$secret_path" ] || continue

            echo "::group::Re-keying: $secret_path"

            # Get recipients for this secret
            jq -r --arg path "$secret_path" '.[$path][]' /tmp/release-work/recipients-map.json > /tmp/recipients.txt

            echo "Recipients: $(wc -l < /tmp/recipients.txt | tr -d ' ') keys"

            # Decrypt with CI key, re-encrypt for all recipients
            age -d -i /tmp/ci-age-key.txt "$secret_path" > /tmp/decrypted.tmp
            age -e -R /tmp/recipients.txt -o "$secret_path.new" /tmp/decrypted.tmp
            mv "$secret_path.new" "$secret_path"
            rm -f /tmp/decrypted.tmp /tmp/recipients.txt

            echo "::endgroup::"
          done

      - name: Commit and push release branch
        run: |
          git config user.name "Forge CI"
          git config user.email "forge@fort.gisi.network"

          # Save recipients map for next run
          cp /tmp/release-work/recipients-map.json .release-recipients.json

          # Capture main's current state
          main_sha=$(git rev-parse --short main)

          # Save the working tree (with re-keyed secrets + map)
          cp -a . /tmp/release-content
          rm -rf /tmp/release-content/.git

          # Fetch release branch
          git fetch origin release || true

          # Stash changes so we can switch branches
          git stash --include-untracked

          # Check out release, or create orphan if it doesn't exist
          if git rev-parse origin/release >/dev/null 2>&1; then
            git checkout -B release origin/release
          else
            git checkout --orphan release
            git rm -rf . || true
          fi

          git stash drop || true

          # Replace release content with main's content
          git rm -rf . || true
          cp -a /tmp/release-content/. .

          # Commit
          git add -A
          git commit -m "release: ${main_sha} - $(date -Iseconds)" \
            || echo "No changes to commit"
          git push origin release
