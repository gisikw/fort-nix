name: Release

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  check:
    runs-on: nixos
    steps:
      - uses: actions/checkout@v4

      - name: Scan for PII
        run: |
          PII_DENYLIST='clusters/bedlam/pii-denylist.age'

          if [ -f "$PII_DENYLIST" ]; then
            echo "$CI_AGE_KEY" > /tmp/ci-age-key.txt
            trap 'rm -f /tmp/ci-age-key.txt' EXIT

            age -d -i /tmp/ci-age-key.txt "$PII_DENYLIST" > /tmp/pii-patterns.txt

            found=0
            while IFS= read -r pattern; do
              [ -z "$pattern" ] && continue
              [[ "$pattern" =~ ^# ]] && continue
              if grep -rliE "\b${pattern}\b" --include="*.nix" . 2>/dev/null; then
                echo "::error::PII pattern detected: $pattern"
                found=1
              fi
            done < /tmp/pii-patterns.txt
            rm -f /tmp/pii-patterns.txt

            if [ "$found" -eq 1 ]; then
              echo "::error::PII detected - blocking build"
              exit 1
            fi
            echo "PII scan passed"
          else
            echo "::warning::No PII denylist at $PII_DENYLIST"
          fi
        env:
          CI_AGE_KEY: ${{ secrets.CI_AGE_KEY }}

      - name: Run Go provider tests
        run: |
          for provider_dir in ./apps/*/provider ./aspects/*/provider; do
            if [ -d "$provider_dir" ] && [ -f "$provider_dir/go.mod" ]; then
              echo "::group::Testing $provider_dir"
              nix-shell -p go --run "cd $provider_dir && go test -v ./..."
              echo "::endgroup::"
            fi
          done

      - name: Check root flake
        run: nix flake check --no-build
        env:
          NIX_CONFIG: "warn-dirty = false"

      - name: Check host flakes
        run: |
          for host_dir in ./clusters/bedlam/hosts/*/; do
            host=$(basename "$host_dir")
            echo "::group::Checking host: $host"
            nix flake check "$host_dir" --no-build
            echo "::endgroup::"
          done
        env:
          NIX_CONFIG: "warn-dirty = false"

      - name: Check device flakes
        run: |
          for device_dir in ./clusters/bedlam/devices/*/; do
            device=$(basename "$device_dir")
            echo "::group::Checking device: $device"
            nix flake check "$device_dir" --no-build
            echo "::endgroup::"
          done
        env:
          NIX_CONFIG: "warn-dirty = false"

  release:
    needs: check
    if: github.event_name == 'push'
    runs-on: nixos
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Collect secrets and build recipients map
        id: collect
        run: |
          mkdir -p /tmp/release-work

          # Will hold: { "path/to/secret.age": { "recipients": ["key1", ...], "contentSha": "abc123" }, ... }
          echo '{}' > /tmp/release-work/recipients-map.json

          for host_dir in ./clusters/bedlam/hosts/*/; do
            host=$(basename "$host_dir")
            echo "::group::Collecting secrets for $host"

            # Get device UUID from host manifest
            device_uuid=$(nix eval --raw --file "${host_dir}/manifest.nix" device 2>/dev/null || echo "")
            if [ -z "$device_uuid" ]; then
              echo "::warning::Could not get device UUID for $host, skipping"
              echo "::endgroup::"
              continue
            fi

            # Get device public key
            device_key=$(nix eval --raw --file "./clusters/bedlam/devices/${device_uuid}/manifest.nix" pubkey 2>/dev/null || echo "")
            if [ -z "$device_key" ]; then
              echo "::warning::Could not get device key for $host (device $device_uuid), skipping"
              echo "::endgroup::"
              continue
            fi

            echo "Device: $device_uuid"
            echo "Key: ${device_key:0:20}..."

            # Get secrets this host uses
            secrets_json=$(nix eval "${host_dir}#nixosConfigurations.${host}.config.age.secrets" --json 2>/dev/null || echo "{}")

            # Extract .file paths and add device key to recipients map
            echo "$secrets_json" | jq -r 'to_entries[] | .value.file // empty' | while read -r secret_file; do
              # Strip /nix/store/*-source/ prefix to get relative path
              secret_path=$(echo "$secret_file" | sed 's|^/nix/store/[^/]*-source/||')
              echo "  Secret: $secret_path"

              # Get the SHA of the last commit that changed this secret file
              content_sha=$(git log -1 --format=%H -- "$secret_path" 2>/dev/null || echo "unknown")

              # Add/update this secret in the map with recipient and content SHA
              jq --arg path "$secret_path" --arg key "$device_key" --arg sha "$content_sha" \
                '.[$path] = {
                  recipients: ((.[$path].recipients // []) + [$key] | unique | sort),
                  contentSha: $sha
                }' \
                /tmp/release-work/recipients-map.json > /tmp/release-work/recipients-map.json.tmp
              mv /tmp/release-work/recipients-map.json.tmp /tmp/release-work/recipients-map.json
            done

            echo "::endgroup::"
          done

          echo "Final recipients map:"
          jq . /tmp/release-work/recipients-map.json
        env:
          NIX_CONFIG: "warn-dirty = false"

      - name: Fetch previous recipients map
        run: |
          # Try to get the previous map from release branch
          if git show origin/release:.release-recipients.json > /tmp/release-work/previous-map.json 2>/dev/null; then
            echo "Found previous recipients map"
            jq . /tmp/release-work/previous-map.json
          else
            echo "No previous map found, all secrets will be re-keyed"
            echo '{}' > /tmp/release-work/previous-map.json
          fi

      - name: Determine secrets to re-key
        run: |
          # Compare maps and output list of secrets that need re-keying
          # Re-key if: recipients changed OR content SHA changed (secret file was modified)
          # Also handles migration from old format (array) to new format (object)
          jq -n --slurpfile current /tmp/release-work/recipients-map.json \
                --slurpfile previous /tmp/release-work/previous-map.json '
            ($current[0] | keys) as $all_secrets |
            $all_secrets | map(
              . as $path |
              $previous[0][$path] as $prev |
              select(
                # Old format was array, new is object - detect and handle migration
                ($prev | type) != "object"
                # OR check if recipients changed
                or ($current[0][$path].recipients | tojson) != ($prev.recipients // [] | tojson)
                # OR check if content SHA changed (secret file was modified on main)
                or ($current[0][$path].contentSha) != ($prev.contentSha // "")
              )
            )
          ' > /tmp/release-work/secrets-to-rekey.json

          echo "Secrets needing re-key:"
          jq -r '.[]' /tmp/release-work/secrets-to-rekey.json

          count=$(jq length /tmp/release-work/secrets-to-rekey.json)
          total=$(jq 'keys | length' /tmp/release-work/recipients-map.json)
          echo "Re-keying $count of $total secrets"

      - name: Copy unchanged secrets from release branch
        run: |
          # For secrets with unchanged recipients AND content, copy from release HEAD
          # This preserves stable ciphertext and avoids spurious deploy triggers
          jq -r 'keys[]' /tmp/release-work/recipients-map.json | while read -r secret_path; do
            # Skip if this secret needs re-keying
            if jq -e --arg p "$secret_path" 'index($p)' /tmp/release-work/secrets-to-rekey.json >/dev/null 2>&1; then
              continue
            fi

            # Try to copy from release branch
            if git show "origin/release:${secret_path}" > "${secret_path}.release" 2>/dev/null; then
              echo "Preserving unchanged: $secret_path"
              mv "${secret_path}.release" "$secret_path"
            else
              echo "::warning::Secret $secret_path not in release branch, will need re-key"
              # Add to re-key list
              jq --arg p "$secret_path" '. + [$p]' /tmp/release-work/secrets-to-rekey.json > /tmp/release-work/secrets-to-rekey.json.tmp
              mv /tmp/release-work/secrets-to-rekey.json.tmp /tmp/release-work/secrets-to-rekey.json
            fi
          done

      - name: Re-key changed secrets
        env:
          CI_AGE_KEY: ${{ secrets.CI_AGE_KEY }}
        run: |
          set -e

          echo "$CI_AGE_KEY" > /tmp/ci-age-key.txt
          trap 'rm -f /tmp/ci-age-key.txt' EXIT

          # Process only secrets that need re-keying
          jq -r '.[]' /tmp/release-work/secrets-to-rekey.json | while read -r secret_path; do
            [ -n "$secret_path" ] || continue

            echo "::group::Re-keying: $secret_path"

            # Get recipients for this secret (now under .recipients key)
            jq -r --arg path "$secret_path" '.[$path].recipients[]' /tmp/release-work/recipients-map.json > /tmp/recipients.txt

            echo "Recipients: $(wc -l < /tmp/recipients.txt | tr -d ' ') keys"

            # Decrypt with CI key, re-encrypt for all recipients
            age -d -i /tmp/ci-age-key.txt "$secret_path" > /tmp/decrypted.tmp

            # Validate decryption produced content (belt-and-suspenders with set -e)
            if [ ! -s /tmp/decrypted.tmp ]; then
              echo "::error::Secret $secret_path decrypted to empty content"
              exit 1
            fi

            age -e -R /tmp/recipients.txt -o "$secret_path.new" /tmp/decrypted.tmp
            mv "$secret_path.new" "$secret_path"
            rm -f /tmp/decrypted.tmp /tmp/recipients.txt

            echo "::endgroup::"
          done

      - name: Commit and push release branch
        run: |
          git config user.name "Forge CI"
          git config user.email "forge@fort.gisi.network"

          # Save recipients map for next run
          cp /tmp/release-work/recipients-map.json .release-recipients.json

          # Capture main's current state
          main_sha=$(git rev-parse --short main)

          # Save the working tree (with re-keyed secrets + map)
          cp -a . /tmp/release-content
          rm -rf /tmp/release-content/.git

          # Fetch release branch
          git fetch origin release || true

          # Stash changes so we can switch branches
          git stash --include-untracked

          # Check out release, or create orphan if it doesn't exist
          if git rev-parse origin/release >/dev/null 2>&1; then
            git checkout -B release origin/release
          else
            git checkout --orphan release
            git rm -rf . || true
          fi

          git stash drop || true

          # Replace release content with main's content
          git rm -rf . || true
          cp -a /tmp/release-content/. .

          # Commit
          git add -A
          git commit -m "release: ${main_sha} - $(date -Iseconds)" \
            || echo "No changes to commit"
          git push origin release

      - name: Push to GitHub mirror
        run: |
          REPO_URL="https://${MIRROR_TOKEN}@github.com/gisikw/fort-nix.git"
          GIT_TERMINAL_PROMPT=0 git push --force "$REPO_URL" main:main
        env:
          MIRROR_TOKEN: ${{ secrets.MIRROR_TOKEN }}
